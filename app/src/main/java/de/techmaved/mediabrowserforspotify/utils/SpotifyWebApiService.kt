package de.techmaved.mediabrowserforspotify.utils

import androidx.compose.runtime.mutableStateOf
import com.adamratzman.spotify.SpotifyClientApi
import com.adamratzman.spotify.models.*
import de.techmaved.mediabrowserforspotify.BuildConfig
import de.techmaved.mediabrowserforspotify.auth.guardValidSpotifyApi
import de.techmaved.mediabrowserforspotify.models.ChipType
import de.techmaved.mediabrowserforspotify.ui.components.ChipItem

class SpotifyWebApiService {
    val mirrorName = "Liked Songs Mirror"
    private val mirrorDescription = "Generated by MediaBrowser for Spotify"

    suspend fun getPlaylists(user: String?): List<SimplePlaylist>? {
        if (user == null) {
            return null
        }

        val playlists = mutableListOf<SimplePlaylist>()
        val limit: Int = getLimit()
        var offset: Int = 0
        var next: String?

        do {
            val userPlaylists =
                guardValidSpotifyApi { api: SpotifyClientApi -> api.playlists.getUserPlaylists(user, limit, offset) }
            playlists.addAll(userPlaylists?.items as Collection<SimplePlaylist>)

            offset += limit
            next = getNext(userPlaylists.next)
        } while (next != null)

        return playlists
    }

    suspend fun getSavedAlbums(): List<SavedAlbum> {
        val savedAlbums = mutableListOf<SavedAlbum>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val albums = guardValidSpotifyApi { api: SpotifyClientApi -> api.library.getSavedAlbums(limit, offset) }
            savedAlbums.addAll(albums?.items as Collection<SavedAlbum>)

            offset += limit
            next = getNext(albums.next)
        } while (next != null)

        return savedAlbums
    }

    suspend fun getAlbumTracks(albumId: String): List<SimpleTrack> {
        val albumTracks = mutableListOf<SimpleTrack>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val tracks = guardValidSpotifyApi { api: SpotifyClientApi -> api.albums.getAlbumTracks(albumId) }
            albumTracks.addAll(tracks?.items as Collection<SimpleTrack>)

            offset += limit
            next = getNext(tracks.next)
        } while (next != null)

        return albumTracks
    }

    suspend fun getPlaylistTracks(playlistId: String): List<PlaylistTrack> {
        val playlistTracks = mutableListOf<PlaylistTrack>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val tracks = guardValidSpotifyApi { api: SpotifyClientApi ->
                api.playlists.getPlaylistTracks(
                    playlistId,
                    limit,
                    offset
                )
            }
            playlistTracks.addAll(tracks?.items as Collection<PlaylistTrack>)

            offset += limit
            next = getNext(tracks.next)
        } while (next != null)

        return playlistTracks
    }

    suspend fun getSavedShows(): List<SavedShow> {
        val shows = mutableListOf<SavedShow>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val savedShows = guardValidSpotifyApi { api: SpotifyClientApi -> api.library.getSavedShows(limit, offset) }
            shows.addAll(savedShows?.items as Collection<SavedShow>)

            offset += limit
            next = getNext(savedShows.next)
        } while (next != null)

        return shows
    }

    suspend fun getShowEpisodes(showId: String): List<SimpleEpisode> {
        val episodes = mutableListOf<SimpleEpisode>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val showEpisodes =
                guardValidSpotifyApi { api: SpotifyClientApi -> api.shows.getShowEpisodes(showId, limit, offset) }
            episodes.addAll(showEpisodes?.items as Collection<SimpleEpisode>)

            offset += limit
            next = getNext(showEpisodes.next)
        } while (next != null)

        return episodes
    }

    suspend fun handleMirror(userName: String) {
        val mirror = getLikedSongsMirror(userName)

        if (mirror == null) {
            val playlist: Playlist? = guardValidSpotifyApi { api: SpotifyClientApi ->
                api.playlists.createClientPlaylist(
                    mirrorName,
                    mirrorDescription,
                    public = false,
                    collaborative = false,
                    user = userName
                )
            }

            if (playlist != null) {
                val savedSongsChunked = getAllSavedTracks().chunked(100)

                savedSongsChunked.forEach { savedTracks ->
                    guardValidSpotifyApi { api: SpotifyClientApi ->
                        api.playlists.addPlayablesToClientPlaylist(
                            playlist = playlist.id,
                            playables = savedTracks.map { it.track.uri }.toTypedArray(),
                        )
                    }
                }

            }

            return
        }

        val savedSongs: List<PlayableUri> = getAllSavedTracks().map { it.track.uri }
        val playlistTracks: List<PlayableUri?> = getPlaylistTracks(mirror.id).map { it.track?.uri }
        val toAddToMirrorPlaylistChunked =
            playlistTracks.let { savedSongs.minus(it.toHashSet()) }.chunked(100)

        val toRemoveFromMirrorPlaylistChunked = playlistTracks.minus(savedSongs.toHashSet())
            .chunked(100)

        toAddToMirrorPlaylistChunked.forEach { playableUris: List<PlayableUri?> ->
            guardValidSpotifyApi { api: SpotifyClientApi ->
                api.playlists.addPlayablesToClientPlaylist(
                    playlist = mirror.id,
                    playables = playableUris.filterNotNull().toTypedArray(),
                    position = 0
                )
            }
        }

        toRemoveFromMirrorPlaylistChunked.forEach { playableUris: List<PlayableUri?> ->
            guardValidSpotifyApi { api: SpotifyClientApi ->
                api.playlists.removePlayablesFromClientPlaylist(
                    playlist = mirror.id,
                    playables = playableUris.filterNotNull().toTypedArray(),
                )
            }
        }
    }

    suspend fun getBrowsables(userName: String): MutableMap<String, List<ChipItem>> {
        val chipItems: MutableMap<String, List<ChipItem>> = mutableMapOf()
        val savedAlbums = this.getSavedAlbums()
        var playlists = this.getPlaylists(userName)
        val shows = this.getSavedShows()
        val likedSongsMirror = this.getLikedSongsMirror(userName)

        if (likedSongsMirror != null) {
            chipItems[ChipType.LIKED_SONGS] = listOf(ChipItem(likedSongsMirror.id, "Liked Songs", mutableStateOf(false)))

            playlists = playlists?.filter { simplePlaylist: SimplePlaylist ->
                return@filter simplePlaylist.id != likedSongsMirror.id
            }
        }

        chipItems[ChipType.ALBUMS] = savedAlbums.map { ChipItem(it.album.id, it.album.name, mutableStateOf(false)) }
        chipItems[ChipType.PLAYLISTS] = playlists?.map { ChipItem(it.id, it.name, mutableStateOf(false)) }!!
        chipItems[ChipType.SHOWS] = shows.map { ChipItem(it.show.id, it.show.name, mutableStateOf(false)) }

        return chipItems
    }

    suspend fun getLikedSongsMirror(userName: String?): SimplePlaylist? {
        if (userName == null) {
            return null
        }

        val playlist = getPlaylists(userName)?.filter { simplePlaylist: SimplePlaylist ->
            simplePlaylist.name == mirrorName || simplePlaylist.description == mirrorDescription
        }

        if (playlist?.isNotEmpty() == true) {
            return playlist[0]
        }

        return null
    }

    private suspend fun getAllSavedTracks(): List<SavedTrack> {
        val tracks = mutableListOf<SavedTrack>()
        var limit: Int = getLimit()
        var offset: Int = 0
        var next: String?

        do {
            val savedTracks =
                guardValidSpotifyApi { api: SpotifyClientApi -> api.library.getSavedTracks(limit, offset) }
            tracks.addAll(savedTracks?.items as Collection<SavedTrack>)

            offset += limit
            next = getNext(savedTracks.next)
        } while (next != null)

        return tracks
    }

    private fun getLimit(): Int {
        if (BuildConfig.DEBUG) {
            return 5
        }

        return 50
    }

    private fun getNext(next: String?): String? {
        if (BuildConfig.DEBUG) {
            return null
        }

        return next
    }
}