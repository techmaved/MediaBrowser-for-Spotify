package de.techmaved.mediabrowserforspotify.utils

import com.adamratzman.spotify.SpotifyClientApi
import com.adamratzman.spotify.models.PlayableUri
import com.adamratzman.spotify.models.Playlist
import com.adamratzman.spotify.models.PlaylistTrack
import com.adamratzman.spotify.models.SavedAlbum
import com.adamratzman.spotify.models.SavedShow
import com.adamratzman.spotify.models.SavedTrack
import com.adamratzman.spotify.models.SimpleEpisode
import com.adamratzman.spotify.models.SimplePlaylist
import com.adamratzman.spotify.models.SimpleTrack
import de.techmaved.mediabrowserforspotify.BuildConfig

class SpotifyWebApiService {
    val mirrorName = "Liked Songs Mirror"
    private val mirrorDescription = "Generated by MediaBrowser for Spotify"

    suspend fun getPlaylists(user: String?): List<SimplePlaylist>? {
        if (user == null) {
            return null
        }

        val playlists = mutableListOf<SimplePlaylist>()
        val limit: Int = getLimit()
        var offset: Int = 0
        var next: String?

        do {
            val userPlaylists =
                guardValidSpotifyApi { api: SpotifyClientApi -> api.playlists.getUserPlaylists(user, limit, offset) }
            playlists.addAll(userPlaylists?.items as Collection<SimplePlaylist>)

            offset += limit
            next = getNext(userPlaylists.next)
        } while (next != null)

        return playlists
    }

    suspend fun getSavedAlbums(): List<SavedAlbum> {
        val savedAlbums = mutableListOf<SavedAlbum>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val albums = guardValidSpotifyApi { api: SpotifyClientApi -> api.library.getSavedAlbums(limit, offset) }
            savedAlbums.addAll(albums?.items as Collection<SavedAlbum>)

            offset += limit
            next = getNext(albums.next)
        } while (next != null)

        return savedAlbums
    }

    suspend fun getAlbumTracks(albumId: String): List<SimpleTrack> {
        val albumTracks = mutableListOf<SimpleTrack>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val tracks = guardValidSpotifyApi { api: SpotifyClientApi -> api.albums.getAlbumTracks(albumId) }
            albumTracks.addAll(tracks?.items as Collection<SimpleTrack>)

            offset += limit
            next = getNext(tracks.next)
        } while (next != null)

        return albumTracks
    }

    suspend fun getPlaylistTracks(playlistId: String): List<PlaylistTrack> {
        val playlistTracks = mutableListOf<PlaylistTrack>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val tracks = guardValidSpotifyApi { api: SpotifyClientApi ->
                api.playlists.getPlaylistTracks(
                    playlistId,
                    limit,
                    offset
                )
            }
            playlistTracks.addAll(tracks?.items as Collection<PlaylistTrack>)

            offset += limit
            next = getNext(tracks.next)
        } while (next != null)

        return playlistTracks
    }

    suspend fun getSavedShows(): List<SavedShow> {
        val shows = mutableListOf<SavedShow>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val savedShows = guardValidSpotifyApi { api: SpotifyClientApi -> api.library.getSavedShows(limit, offset) }
            shows.addAll(savedShows?.items as Collection<SavedShow>)

            offset += limit
            next = getNext(savedShows.next)
        } while (next != null)

        return shows
    }

    suspend fun getShowEpisodes(showId: String): List<SimpleEpisode> {
        val episodes = mutableListOf<SimpleEpisode>()
        val limit = getLimit()
        var offset = 0
        var next: String?

        do {
            val showEpisodes =
                guardValidSpotifyApi { api: SpotifyClientApi -> api.shows.getShowEpisodes(showId, limit, offset) }
            episodes.addAll(showEpisodes?.items as Collection<SimpleEpisode>)

            offset += limit
            next = getNext(showEpisodes.next)
        } while (next != null)

        return episodes
    }

    suspend fun handleMirror() {
        val username = guardValidSpotifyApi { api: SpotifyClientApi -> api.getUserId() }
        val userPlaylists = getPlaylists(username)

        val mirror = userPlaylists?.filter { simplePlaylist: SimplePlaylist ->
            simplePlaylist.name == mirrorName || simplePlaylist.description == mirrorDescription
        }

        if (mirror?.isEmpty() == true) {
            val playlist: Playlist? = guardValidSpotifyApi { api: SpotifyClientApi ->
                api.playlists.createClientPlaylist(
                    mirrorName,
                    mirrorDescription,
                    public = false,
                    collaborative = false,
                    user = username
                )
            }

            if (playlist != null) {
                val savedSongsChunked = getAllSavedTracks().chunked(100)

                savedSongsChunked.forEach { savedTracks ->
                    guardValidSpotifyApi { api: SpotifyClientApi ->
                        api.playlists.addPlayablesToClientPlaylist(
                            playlist = playlist.id,
                            playables = savedTracks.map { it.track.uri }.toTypedArray(),
                        )
                    }
                }

            }

            return
        }

        mirror?.get(0).let { playlist: SimplePlaylist? ->
            val savedSongs: List<PlayableUri> = getAllSavedTracks().map { it.track.uri }

            val playlistTracks: List<PlayableUri?>? = playlist?.id?.let {
                getPlaylistTracks(it)
            }?.map {
                it.track?.uri
            }

            val toAddToMirrorPlaylistChunked =
                playlistTracks?.let { savedSongs.minus(it.toHashSet()) }?.chunked(100)

            val toRemoveFromMirrorPlaylistChunked = playlistTracks?.minus(savedSongs.toHashSet())
                ?.chunked(100)

            toAddToMirrorPlaylistChunked?.forEach { playableUris: List<PlayableUri?> ->
                guardValidSpotifyApi { api: SpotifyClientApi ->
                    api.playlists.addPlayablesToClientPlaylist(
                        playlist = playlist.id,
                        playables = playableUris.filterNotNull().toTypedArray(),
                        position = 0
                    )
                }
            }

            toRemoveFromMirrorPlaylistChunked?.forEach { playableUris: List<PlayableUri?> ->
                guardValidSpotifyApi { api: SpotifyClientApi ->
                    api.playlists.removePlayablesFromClientPlaylist(
                        playlist = playlist.id,
                        playables = playableUris.filterNotNull().toTypedArray(),
                    )
                }
            }
        }
    }

    private suspend fun getAllSavedTracks(): List<SavedTrack> {
        val tracks = mutableListOf<SavedTrack>()
        var limit: Int = getLimit()
        var offset: Int = 0
        var next: String?

        do {
            val savedTracks =
                guardValidSpotifyApi { api: SpotifyClientApi -> api.library.getSavedTracks(limit, offset) }
            tracks.addAll(savedTracks?.items as Collection<SavedTrack>)

            offset += limit
            next = getNext(savedTracks.next)
        } while (next != null)

        return tracks
    }

    private fun getLimit(): Int {
        if (BuildConfig.DEBUG) {
            return 5
        }

        return 50
    }

    private fun getNext(next: String?): String? {
        if (BuildConfig.DEBUG) {
            return null
        }

        return next
    }
}